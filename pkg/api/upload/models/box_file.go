package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// BoxFile File Object
//
// File information describe file objects in Box, with attributes like who created the file, when it was last modified, and other information. The actual content of the file itself is accessible through the /files/{id}/content endpoint.
// swagger:model BoxFile
type BoxFile struct {
	FileReference

	// collections
	Collections []*Collection `json:"collections"`

	// The number of comments on a file.
	CommentCount int64 `json:"comment_count,omitempty"`

	// When the content of this file was created (more info).
	ContentCreatedAt strfmt.DateTime `json:"content_created_at,omitempty"`

	// When the content of this file was last modified (more info).
	ContentModifiedAt strfmt.DateTime `json:"content_modified_at,omitempty"`

	// When this file was created on Boxâ€™s servers.
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// The user who first created file.
	CreatedBy *UserReference `json:"created_by,omitempty"`

	// The description of this file.
	Description string `json:"description,omitempty"`

	// An expiring URL for an embedded preview session in an iframe. This URL will expire after 60 seconds and the session will expire after 60 minutes.
	ExpiringEmbedLink string `json:"expiring_embed_link,omitempty"`

	// Indicates the suffix, when available, on the file. By default, set to an empty string. The suffix usually indicates the encoding (file format) of the file contents or usage.
	Extension string `json:"extension,omitempty"`

	// file version
	FileVersion *FileVersionReference `json:"file_version,omitempty"`

	// Whether the file is a package. Used for Mac Packages used by iWorks.
	IsPackage bool `json:"is_package,omitempty"`

	// Whether this item is deleted or not.
	ItemStatus string `json:"item_status,omitempty"`

	// lock
	Lock *Lock `json:"lock,omitempty"`

	// When this file was last updated on the Box servers.
	ModifiedAt strfmt.DateTime `json:"modified_at,omitempty"`

	// The user who last updated this file.
	ModifiedBy *UserReference `json:"modified_by,omitempty"`

	// The user who owns this file.
	OwnedBy *UserReference `json:"owned_by,omitempty"`

	// The folder containing this file.
	Parent *ItemReference `json:"parent,omitempty"`

	// The path of folders to this file, starting at the root.
	PathCollection *PathCollection `json:"path_collection,omitempty"`

	// permissions
	Permissions *FilePermissions `json:"permissions,omitempty"`

	// When this file will be permanently deleted.
	PurgedAt strfmt.DateTime `json:"purged_at,omitempty"`

	// shared link
	SharedLink *SharedLink `json:"shared_link,omitempty"`

	// Size of this file in bytes.
	Size int64 `json:"size,omitempty"`

	// All tags applied to this file.
	Tags []string `json:"tags"`

	// When this file was last moved to the trash.
	TrashedAt strfmt.DateTime `json:"trashed_at,omitempty"`

	// The version number of the file.
	VersionNumber string `json:"version_number,omitempty"`

	// watermark info
	WatermarkInfo WatermarkInfo `json:"watermark_info"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *BoxFile) UnmarshalJSON(raw []byte) error {

	var aO0 FileReference
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.FileReference = aO0

	var data struct {
		Collections []*Collection `json:"collections,omitempty"`

		CommentCount int64 `json:"comment_count,omitempty"`

		ContentCreatedAt strfmt.DateTime `json:"content_created_at,omitempty"`

		ContentModifiedAt strfmt.DateTime `json:"content_modified_at,omitempty"`

		CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

		CreatedBy *UserReference `json:"created_by,omitempty"`

		Description string `json:"description,omitempty"`

		ExpiringEmbedLink string `json:"expiring_embed_link,omitempty"`

		Extension string `json:"extension,omitempty"`

		FileVersion *FileVersionReference `json:"file_version,omitempty"`

		IsPackage bool `json:"is_package,omitempty"`

		ItemStatus string `json:"item_status,omitempty"`

		Lock *Lock `json:"lock,omitempty"`

		ModifiedAt strfmt.DateTime `json:"modified_at,omitempty"`

		ModifiedBy *UserReference `json:"modified_by,omitempty"`

		OwnedBy *UserReference `json:"owned_by,omitempty"`

		Parent *ItemReference `json:"parent,omitempty"`

		PathCollection *PathCollection `json:"path_collection,omitempty"`

		Permissions *FilePermissions `json:"permissions,omitempty"`

		PurgedAt strfmt.DateTime `json:"purged_at,omitempty"`

		SharedLink *SharedLink `json:"shared_link,omitempty"`

		Size int64 `json:"size,omitempty"`

		Tags []string `json:"tags,omitempty"`

		TrashedAt strfmt.DateTime `json:"trashed_at,omitempty"`

		VersionNumber string `json:"version_number,omitempty"`

		WatermarkInfo WatermarkInfo `json:"watermark_info,omitempty"`
	}
	if err := swag.ReadJSON(raw, &data); err != nil {
		return err
	}

	m.Collections = data.Collections

	m.CommentCount = data.CommentCount

	m.ContentCreatedAt = data.ContentCreatedAt

	m.ContentModifiedAt = data.ContentModifiedAt

	m.CreatedAt = data.CreatedAt

	m.CreatedBy = data.CreatedBy

	m.Description = data.Description

	m.ExpiringEmbedLink = data.ExpiringEmbedLink

	m.Extension = data.Extension

	m.FileVersion = data.FileVersion

	m.IsPackage = data.IsPackage

	m.ItemStatus = data.ItemStatus

	m.Lock = data.Lock

	m.ModifiedAt = data.ModifiedAt

	m.ModifiedBy = data.ModifiedBy

	m.OwnedBy = data.OwnedBy

	m.Parent = data.Parent

	m.PathCollection = data.PathCollection

	m.Permissions = data.Permissions

	m.PurgedAt = data.PurgedAt

	m.SharedLink = data.SharedLink

	m.Size = data.Size

	m.Tags = data.Tags

	m.TrashedAt = data.TrashedAt

	m.VersionNumber = data.VersionNumber

	m.WatermarkInfo = data.WatermarkInfo

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m BoxFile) MarshalJSON() ([]byte, error) {
	var _parts [][]byte

	aO0, err := swag.WriteJSON(m.FileReference)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var data struct {
		Collections []*Collection `json:"collections,omitempty"`

		CommentCount int64 `json:"comment_count,omitempty"`

		ContentCreatedAt strfmt.DateTime `json:"content_created_at,omitempty"`

		ContentModifiedAt strfmt.DateTime `json:"content_modified_at,omitempty"`

		CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

		CreatedBy *UserReference `json:"created_by,omitempty"`

		Description string `json:"description,omitempty"`

		ExpiringEmbedLink string `json:"expiring_embed_link,omitempty"`

		Extension string `json:"extension,omitempty"`

		FileVersion *FileVersionReference `json:"file_version,omitempty"`

		IsPackage bool `json:"is_package,omitempty"`

		ItemStatus string `json:"item_status,omitempty"`

		Lock *Lock `json:"lock,omitempty"`

		ModifiedAt strfmt.DateTime `json:"modified_at,omitempty"`

		ModifiedBy *UserReference `json:"modified_by,omitempty"`

		OwnedBy *UserReference `json:"owned_by,omitempty"`

		Parent *ItemReference `json:"parent,omitempty"`

		PathCollection *PathCollection `json:"path_collection,omitempty"`

		Permissions *FilePermissions `json:"permissions,omitempty"`

		PurgedAt strfmt.DateTime `json:"purged_at,omitempty"`

		SharedLink *SharedLink `json:"shared_link,omitempty"`

		Size int64 `json:"size,omitempty"`

		Tags []string `json:"tags,omitempty"`

		TrashedAt strfmt.DateTime `json:"trashed_at,omitempty"`

		VersionNumber string `json:"version_number,omitempty"`

		WatermarkInfo WatermarkInfo `json:"watermark_info,omitempty"`
	}

	data.Collections = m.Collections

	data.CommentCount = m.CommentCount

	data.ContentCreatedAt = m.ContentCreatedAt

	data.ContentModifiedAt = m.ContentModifiedAt

	data.CreatedAt = m.CreatedAt

	data.CreatedBy = m.CreatedBy

	data.Description = m.Description

	data.ExpiringEmbedLink = m.ExpiringEmbedLink

	data.Extension = m.Extension

	data.FileVersion = m.FileVersion

	data.IsPackage = m.IsPackage

	data.ItemStatus = m.ItemStatus

	data.Lock = m.Lock

	data.ModifiedAt = m.ModifiedAt

	data.ModifiedBy = m.ModifiedBy

	data.OwnedBy = m.OwnedBy

	data.Parent = m.Parent

	data.PathCollection = m.PathCollection

	data.Permissions = m.Permissions

	data.PurgedAt = m.PurgedAt

	data.SharedLink = m.SharedLink

	data.Size = m.Size

	data.Tags = m.Tags

	data.TrashedAt = m.TrashedAt

	data.VersionNumber = m.VersionNumber

	data.WatermarkInfo = m.WatermarkInfo

	jsonData, err := swag.WriteJSON(data)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, jsonData)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this box file
func (m *BoxFile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.FileReference.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCollections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOwnedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSharedLink(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BoxFile) validateCollections(formats strfmt.Registry) error {

	if swag.IsZero(m.Collections) { // not required
		return nil
	}

	for i := 0; i < len(m.Collections); i++ {

		if swag.IsZero(m.Collections[i]) { // not required
			continue
		}

		if m.Collections[i] != nil {

			if err := m.Collections[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("collections" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BoxFile) validateCreatedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedBy) { // not required
		return nil
	}

	if m.CreatedBy != nil {

		if err := m.CreatedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("created_by")
			}
			return err
		}
	}

	return nil
}

func (m *BoxFile) validateModifiedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.ModifiedBy) { // not required
		return nil
	}

	if m.ModifiedBy != nil {

		if err := m.ModifiedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("modified_by")
			}
			return err
		}
	}

	return nil
}

func (m *BoxFile) validateOwnedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.OwnedBy) { // not required
		return nil
	}

	if m.OwnedBy != nil {

		if err := m.OwnedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("owned_by")
			}
			return err
		}
	}

	return nil
}

func (m *BoxFile) validatePermissions(formats strfmt.Registry) error {

	if swag.IsZero(m.Permissions) { // not required
		return nil
	}

	if m.Permissions != nil {

		if err := m.Permissions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("permissions")
			}
			return err
		}
	}

	return nil
}

func (m *BoxFile) validateSharedLink(formats strfmt.Registry) error {

	if swag.IsZero(m.SharedLink) { // not required
		return nil
	}

	if m.SharedLink != nil {

		if err := m.SharedLink.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("shared_link")
			}
			return err
		}
	}

	return nil
}

func (m *BoxFile) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BoxFile) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BoxFile) UnmarshalBinary(b []byte) error {
	var res BoxFile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
